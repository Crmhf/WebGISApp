var VSHADER_SOURCE="uniform mat4 u_perspectiveMatrix;\nuniform mat4 u_modelMatrix;\nuniform mat4 u_viewMatrix;\nuniform float u_time;\n\nattribute vec4 a_Position;\n\nvarying vec4 v_Color;\n\nvoid main() {\n  vec4 position = a_Position;\n  float dist = length( vec3(position));\n  float y = sin(dist*20.0 + u_time);\n  position.y = y * 0.05;\n  mat4 modelViewMatrix = u_viewMatrix * u_modelMatrix;\n  gl_Position = u_perspectiveMatrix * modelViewMatrix * position;\n\n  float c = (y+1.0) * 0.5 * 0.8+0.2;\n  v_Color = vec4(c, c, c, 1.0);\n}\n";var FSHADER_SOURCE="#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec4 v_Color;\nvoid main() {\n  gl_FragColor = v_Color;\n}\n";var g_perspectiveMatrix=new Matrix4();var g_modelMatrix=new Matrix4();var g_viewMatrix=new Matrix4();var g_vertexPositionBuffer;var g_vertexIndexBuffer;var g_vertexIndexNum;function main(){var d=document.getElementById("example");var h=getWebGLContext(d);if(!h){console.log("Failed to get the rendering context for WebGL");return}if(!initShaders(h,VSHADER_SOURCE,FSHADER_SOURCE)){console.log("Failed to intialize shaders.");return}var c=h.getUniformLocation(h.program,"u_perspectiveMatrix");var b=h.getUniformLocation(h.program,"u_modelMatrix");var a=h.getUniformLocation(h.program,"u_viewMatrix");var f=h.getUniformLocation(h.program,"u_time");h.enable(h.DEPTH_TEST);h.clearColor(0,0,0,1);sendGridVertexBuffers(h);var g=0;var e=function(){window.requestAnimationFrame(e);g+=0.02;h.uniform1f(f,g);drawCommon(h,d,c,a);drawGrid(h,c,b)};e()}function drawCommon(d,c,b,a){d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT);g_perspectiveMatrix.setPerspective(30,c.width/c.height,1,10000);g_viewMatrix.setLookAt(0,3,5,0,0,0,0,1,0);d.uniformMatrix4fv(b,false,g_perspectiveMatrix.elements);d.uniformMatrix4fv(a,false,g_viewMatrix.elements)}function drawGrid(d,b,a){d.bindBuffer(d.ARRAY_BUFFER,g_vertexPositionBuffer);var c=d.getAttribLocation(d.program,"a_Position");d.vertexAttribPointer(c,3,d.FLOAT,false,0,0);d.enableVertexAttribArray(c);d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,g_vertexIndexBuffer);g_modelMatrix.setTranslate(0,0,0);g_modelMatrix.rotate(0,0,1,0);g_modelMatrix.scale(1,1,1);d.uniformMatrix4fv(a,false,g_modelMatrix.elements);d.drawElements(d.TRIANGLES,g_vertexIndexNum,d.UNSIGNED_SHORT,0)}function sendGridVertexBuffers(e){var d=[];var c=[];var b=200;var f=200;var a=5;var i=5;for(var g=0;g<f;g++){for(var h=0;h<b;h++){d.push((h-b/2)*a/b);d.push(0);d.push((g-f/2)*i/f)}}for(var g=0;g<f-1;g++){for(var h=0;h<b-1;h++){c.push(g*b+h+0);c.push(g*b+h+1);c.push(g*b+h+b+0);c.push(g*b+h+1);c.push(g*b+h+b+0);c.push(g*b+h+b+1)}}g_vertexPositionBuffer=e.createBuffer();g_vertexIndexBuffer=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,g_vertexPositionBuffer);e.bufferData(e.ARRAY_BUFFER,new Float32Array(d),e.STATIC_DRAW);e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,g_vertexIndexBuffer);e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(c),e.STATIC_DRAW);g_vertexIndexNum=c.length;return true};